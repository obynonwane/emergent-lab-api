"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.PgInstrumentation = void 0;
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const instrumentation_1 = require("@opentelemetry/instrumentation");
const api_1 = require("@opentelemetry/api");
const utils = require("./utils");
const enums_1 = require("./enums");
const version_1 = require("./version");
const PG_POOL_COMPONENT = 'pg-pool';
class PgInstrumentation extends instrumentation_1.InstrumentationBase {
    constructor(config = {}) {
        super('@opentelemetry/instrumentation-pg', version_1.VERSION, Object.assign({}, config));
    }
    init() {
        const modulePG = new instrumentation_1.InstrumentationNodeModuleDefinition('pg', ['7.*', '8.*'], moduleExports => {
            if (instrumentation_1.isWrapped(moduleExports.Client.prototype.query)) {
                this._unwrap(moduleExports.Client.prototype, 'query');
            }
            this._wrap(moduleExports.Client.prototype, 'query', this._getClientQueryPatch());
            return moduleExports;
        }, moduleExports => {
            if (instrumentation_1.isWrapped(moduleExports.Client.prototype.query)) {
                this._unwrap(moduleExports.Client.prototype, 'query');
            }
        });
        const modulePGPool = new instrumentation_1.InstrumentationNodeModuleDefinition('pg-pool', ['2.*', '3.*'], moduleExports => {
            if (instrumentation_1.isWrapped(moduleExports.prototype.connect)) {
                this._unwrap(moduleExports.prototype, 'connect');
            }
            this._wrap(moduleExports.prototype, 'connect', this._getPoolConnectPatch());
            return moduleExports;
        }, moduleExports => {
            if (instrumentation_1.isWrapped(moduleExports.prototype.connect)) {
                this._unwrap(moduleExports.prototype, 'connect');
            }
        });
        return [modulePG, modulePGPool];
    }
    _getClientQueryPatch() {
        const plugin = this;
        return (original) => {
            api_1.diag.debug(`Patching ${PgInstrumentation.COMPONENT}.Client.prototype.query`);
            return function query(...args) {
                let span;
                // Handle different client.query(...) signatures
                if (typeof args[0] === 'string') {
                    const query = args[0];
                    if (args.length > 1 && args[1] instanceof Array) {
                        const params = args[1];
                        span = utils.handleParameterizedQuery.call(this, plugin.tracer, plugin._config, query, params);
                    }
                    else {
                        span = utils.handleTextQuery.call(this, plugin.tracer, query);
                    }
                }
                else if (typeof args[0] === 'object') {
                    const queryConfig = args[0];
                    span = utils.handleConfigQuery.call(this, plugin.tracer, plugin._config, queryConfig);
                }
                else {
                    return utils.handleInvalidQuery.call(this, plugin.tracer, original, ...args);
                }
                // Bind callback to parent span
                if (args.length > 0) {
                    const parentSpan = api_1.getSpan(api_1.context.active());
                    if (typeof args[args.length - 1] === 'function') {
                        // Patch ParameterQuery callback
                        args[args.length - 1] = utils.patchCallback(span, args[args.length - 1]);
                        // If a parent span exists, bind the callback
                        if (parentSpan) {
                            args[args.length - 1] = api_1.context.bind(args[args.length - 1]);
                        }
                    }
                    else if (typeof args[0].callback === 'function') {
                        // Patch ConfigQuery callback
                        let callback = utils.patchCallback(span, args[0].callback);
                        // If a parent span existed, bind the callback
                        if (parentSpan) {
                            callback = api_1.context.bind(callback);
                        }
                        // Copy the callback instead of writing to args.callback so that we don't modify user's
                        // original callback reference
                        args[0] = Object.assign(Object.assign({}, args[0]), { callback });
                    }
                }
                // Perform the original query
                const result = original.apply(this, args);
                // Bind promise to parent span and end the span
                if (result instanceof Promise) {
                    return result
                        .then((result) => {
                        // Return a pass-along promise which ends the span and then goes to user's orig resolvers
                        return new Promise(resolve => {
                            span.end();
                            resolve(result);
                        });
                    })
                        .catch((error) => {
                        return new Promise((_, reject) => {
                            span.setStatus({
                                code: api_1.SpanStatusCode.ERROR,
                                message: error.message,
                            });
                            span.end();
                            reject(error);
                        });
                    });
                }
                // else returns void
                return result; // void
            };
        };
    }
    _getPoolConnectPatch() {
        const plugin = this;
        return (originalConnect) => {
            return function connect(callback) {
                const jdbcString = utils.getJDBCString(this.options);
                // setup span
                const span = plugin.tracer.startSpan(`${PG_POOL_COMPONENT}.connect`, {
                    kind: api_1.SpanKind.CLIENT,
                    attributes: {
                        [enums_1.AttributeNames.COMPONENT]: PgInstrumentation.COMPONENT,
                        [enums_1.AttributeNames.DB_TYPE]: PgInstrumentation.DB_TYPE,
                        [enums_1.AttributeNames.DB_INSTANCE]: this.options.database,
                        [enums_1.AttributeNames.PEER_HOSTNAME]: this.options.host,
                        [enums_1.AttributeNames.PEER_ADDRESS]: jdbcString,
                        [enums_1.AttributeNames.PEER_PORT]: this.options.port,
                        [enums_1.AttributeNames.DB_USER]: this.options.user,
                        [enums_1.AttributeNames.IDLE_TIMEOUT_MILLIS]: this.options
                            .idleTimeoutMillis,
                        [enums_1.AttributeNames.MAX_CLIENT]: this.options.maxClient,
                    },
                });
                if (callback) {
                    const parentSpan = api_1.getSpan(api_1.context.active());
                    callback = utils.patchCallbackPGPool(span, callback);
                    // If a parent span exists, bind the callback
                    if (parentSpan) {
                        callback = api_1.context.bind(callback);
                    }
                }
                const connectResult = originalConnect.call(this, callback);
                // No callback was provided, return a promise instead
                if (connectResult instanceof Promise) {
                    const connectResultPromise = connectResult;
                    return api_1.context.bind(connectResultPromise
                        .then(result => {
                        // Return a pass-along promise which ends the span and then goes to user's orig resolvers
                        return new Promise(resolve => {
                            span.end();
                            resolve(result);
                        });
                    })
                        .catch((error) => {
                        return new Promise((_, reject) => {
                            span.setStatus({
                                code: api_1.SpanStatusCode.ERROR,
                                message: error.message,
                            });
                            span.end();
                            reject(error);
                        });
                    }));
                }
                // Else a callback was provided, so just return the result
                return connectResult;
            };
        };
    }
}
exports.PgInstrumentation = PgInstrumentation;
PgInstrumentation.COMPONENT = 'pg';
PgInstrumentation.DB_TYPE = 'sql';
PgInstrumentation.BASE_SPAN_NAME = PgInstrumentation.COMPONENT + '.query';
//# sourceMappingURL=pg.js.map