"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SpanShim = exports.TracerShim = exports.SpanContextShim = void 0;
const api = require("@opentelemetry/api");
const opentracing = require("opentracing");
const api_1 = require("@opentelemetry/api");
function translateReferences(references) {
    const links = [];
    for (const reference of references) {
        const context = reference.referencedContext();
        if (context instanceof SpanContextShim) {
            links.push({
                context: context.getSpanContext(),
                attributes: { 'span.kind': reference.type() },
            });
        }
    }
    return links;
}
function translateSpanOptions(options) {
    const opts = {
        startTime: options.startTime,
    };
    if (options.references) {
        opts.links = translateReferences(options.references);
    }
    return opts;
}
function getContextWithParent(options) {
    if (options.childOf) {
        if (options.childOf instanceof SpanShim) {
            return api.setSpan(api.context.active(), options.childOf.getSpan());
        }
        else if (options.childOf instanceof SpanContextShim) {
            return api.setSpanContext(api.context.active(), options.childOf.getSpanContext());
        }
    }
    return api.context.active();
}
/**
 * SpanContextShim wraps a {@link types.SpanContext} and implements the
 * OpenTracing span context API.
 */
class SpanContextShim extends opentracing.SpanContext {
    constructor(spanContext, baggage) {
        super();
        this._spanContext = spanContext;
        this._baggage = baggage;
    }
    /**
     * Returns the underlying {@link types.SpanContext}
     */
    getSpanContext() {
        return this._spanContext;
    }
    /**
     * Returns the underlying {@link api.Baggage}
     */
    getBaggage() {
        return this._baggage;
    }
    /**
     * Returns the trace ID as a string.
     */
    toTraceId() {
        return this._spanContext.traceId;
    }
    /**
     * Returns the span ID as a string.
     */
    toSpanId() {
        return this._spanContext.spanId;
    }
    getBaggageItem(key) {
        var _a;
        return (_a = this._baggage.getEntry(key)) === null || _a === void 0 ? void 0 : _a.value;
    }
    setBaggageItem(key, value) {
        this._baggage = this._baggage.setEntry(key, { value });
    }
}
exports.SpanContextShim = SpanContextShim;
/**
 * TracerShim wraps a {@link types.Tracer} and implements the
 * OpenTracing tracer API.
 */
class TracerShim extends opentracing.Tracer {
    constructor(tracer) {
        super();
        this._tracer = tracer;
    }
    startSpan(name, options = {}) {
        const span = this._tracer.startSpan(name, translateSpanOptions(options), getContextWithParent(options));
        let baggage = api_1.createBaggage();
        if (options.childOf instanceof SpanShim) {
            const shimContext = options.childOf.context();
            baggage = shimContext.getBaggage();
        }
        else if (options.childOf instanceof SpanContextShim) {
            baggage = options.childOf.getBaggage();
        }
        if (options.tags) {
            span.setAttributes(options.tags);
        }
        return new SpanShim(this, span, baggage);
    }
    _inject(spanContext, format, carrier) {
        const spanContextShim = spanContext;
        const oTelSpanContext = spanContextShim.getSpanContext();
        const oTelSpanBaggage = spanContextShim.getBaggage();
        if (!carrier || typeof carrier !== 'object')
            return;
        switch (format) {
            case opentracing.FORMAT_HTTP_HEADERS:
            case opentracing.FORMAT_TEXT_MAP: {
                api.propagation.inject(api.setBaggage(api.setSpanContext(api.ROOT_CONTEXT, oTelSpanContext), oTelSpanBaggage), carrier);
                return;
            }
            case opentracing.FORMAT_BINARY: {
                api.diag.warn('OpentracingShim.inject() does not support FORMAT_BINARY');
                // @todo: Implement binary formats
                return;
            }
            default:
        }
    }
    _extract(format, carrier) {
        switch (format) {
            case opentracing.FORMAT_HTTP_HEADERS:
            case opentracing.FORMAT_TEXT_MAP: {
                const context = api.propagation.extract(api.ROOT_CONTEXT, carrier);
                const spanContext = api.getSpanContext(context);
                const baggage = api.getBaggage(context);
                if (!spanContext) {
                    return null;
                }
                return new SpanContextShim(spanContext, baggage || api_1.createBaggage());
            }
            case opentracing.FORMAT_BINARY: {
                // @todo: Implement binary format
                api.diag.warn('OpentracingShim.extract() does not support FORMAT_BINARY');
                return null;
            }
            default:
        }
        return null;
    }
}
exports.TracerShim = TracerShim;
/**
 * SpanShim wraps an {@link types.Span} and implements the OpenTracing Span API
 * around it.
 *
 **/
class SpanShim extends opentracing.Span {
    constructor(tracerShim, span, baggage) {
        super();
        this._span = span;
        this._contextShim = new SpanContextShim(span.context(), baggage);
        this._tracerShim = tracerShim;
    }
    /**
     * Returns a reference to the Span's context.
     *
     * @returns a {@link SpanContextShim} containing the underlying context.
     */
    context() {
        return this._contextShim;
    }
    /**
     * Returns the {@link opentracing.Tracer} that created the span.
     */
    tracer() {
        return this._tracerShim;
    }
    /**
     * Updates the underlying span's name.
     *
     * @param name the Span name.
     */
    setOperationName(name) {
        this._span.updateName(name);
        return this;
    }
    /**
     * Finishes the span. Once the span is finished, no new updates can be applied
     * to the span.
     *
     * @param finishTime An optional timestamp to explicitly set the span's end time.
     */
    finish(finishTime) {
        this._span.end(finishTime);
    }
    /**
     * Logs an event with an optional payload.
     * @param eventName name of the event.
     * @param payload an arbitrary object to be attached to the event.
     */
    logEvent(eventName, payload) {
        this._span.addEvent(eventName, payload);
    }
    /**
     * Logs a set of key value pairs. Since OpenTelemetry only supports events,
     * the KV pairs are used as attributes on an event named "log".
     */
    log(keyValuePairs, _timestamp) {
        // @todo: Handle timestamp
        this._span.addEvent('log', keyValuePairs);
        return this;
    }
    /**
     * Adds a set of tags to the span.
     * @param keyValueMap set of KV pairs representing tags
     */
    addTags(keyValueMap) {
        this._span.setAttributes(keyValueMap);
        return this;
    }
    /**
     * Sets a tag on the span, updating the value if the key is already present
     * on the span.
     * @param key key for the tag
     * @param value value for the tag
     */
    setTag(key, value) {
        if (key === opentracing.Tags.ERROR &&
            (value === true || value === 'true')) {
            this._span.setStatus({ code: api.SpanStatusCode.ERROR });
            return this;
        }
        this._span.setAttribute(key, value);
        return this;
    }
    getBaggageItem(key) {
        return this._contextShim.getBaggageItem(key);
    }
    setBaggageItem(key, value) {
        this._contextShim.setBaggageItem(key, value);
        return this;
    }
    /*
     * Returns the underlying {@link types.Span} that the shim
     * is wrapping.
     */
    getSpan() {
        return this._span;
    }
}
exports.SpanShim = SpanShim;
//# sourceMappingURL=shim.js.map