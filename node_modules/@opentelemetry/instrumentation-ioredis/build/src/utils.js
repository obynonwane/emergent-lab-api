"use strict";
/*
 * Copyright The OpenTelemetry Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.traceSendCommand = exports.traceConnection = void 0;
const api_1 = require("@opentelemetry/api");
const ioredis_1 = require("./ioredis");
const semantic_conventions_1 = require("@opentelemetry/semantic-conventions");
const instrumentation_1 = require("@opentelemetry/instrumentation");
const endSpan = (span, err) => {
    if (err) {
        span.recordException(err);
        span.setStatus({
            code: api_1.SpanStatusCode.ERROR,
            message: err.message,
        });
    }
    span.end();
};
exports.traceConnection = (tracer, original) => {
    return function () {
        const span = tracer.startSpan('connect', {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
                [semantic_conventions_1.SemanticAttributes.DB_SYSTEM]: ioredis_1.IORedisInstrumentation.DB_SYSTEM,
                [semantic_conventions_1.SemanticAttributes.DB_STATEMENT]: 'connect',
            },
        });
        const { host, port } = this.options;
        span.setAttributes({
            [semantic_conventions_1.SemanticAttributes.NET_PEER_NAME]: host,
            [semantic_conventions_1.SemanticAttributes.NET_PEER_PORT]: port,
            [semantic_conventions_1.SemanticAttributes.NET_PEER_IP]: `redis://${host}:${port}`,
        });
        try {
            const client = original.apply(this, arguments);
            endSpan(span, null);
            return client;
        }
        catch (error) {
            endSpan(span, error);
            throw error;
        }
    };
};
const defaultDbStatementSerializer = (cmdName, cmdArgs) => Array.isArray(cmdArgs) && cmdArgs.length
    ? `${cmdName} ${cmdArgs.join(' ')}`
    : cmdName;
exports.traceSendCommand = (tracer, original, config) => {
    const dbStatementSerializer = (config === null || config === void 0 ? void 0 : config.dbStatementSerializer) || defaultDbStatementSerializer;
    return function (cmd) {
        if (arguments.length < 1 || typeof cmd !== 'object') {
            return original.apply(this, arguments);
        }
        const hasNoParentSpan = api_1.getSpan(api_1.context.active()) === undefined;
        if ((config === null || config === void 0 ? void 0 : config.requireParentSpan) === true && hasNoParentSpan) {
            return original.apply(this, arguments);
        }
        const span = tracer.startSpan(cmd.name, {
            kind: api_1.SpanKind.CLIENT,
            attributes: {
                [semantic_conventions_1.SemanticAttributes.DB_SYSTEM]: ioredis_1.IORedisInstrumentation.DB_SYSTEM,
                [semantic_conventions_1.SemanticAttributes.DB_STATEMENT]: dbStatementSerializer(cmd.name, cmd.args),
            },
        });
        const { host, port } = this.options;
        span.setAttributes({
            [semantic_conventions_1.SemanticAttributes.NET_PEER_NAME]: host,
            [semantic_conventions_1.SemanticAttributes.NET_PEER_PORT]: port,
            [semantic_conventions_1.SemanticAttributes.NET_PEER_IP]: `redis://${host}:${port}`,
        });
        try {
            const result = original.apply(this, arguments);
            const origResolve = cmd.resolve;
            /* eslint-disable @typescript-eslint/no-explicit-any */
            cmd.resolve = function (result) {
                instrumentation_1.safeExecuteInTheMiddle(() => { var _a; return (_a = config === null || config === void 0 ? void 0 : config.responseHook) === null || _a === void 0 ? void 0 : _a.call(config, span, cmd.name, cmd.args, result); }, e => {
                    if (e) {
                        api_1.diag.error('ioredis response hook failed', e);
                    }
                }, true);
                endSpan(span, null);
                origResolve(result);
            };
            const origReject = cmd.reject;
            cmd.reject = function (err) {
                endSpan(span, err);
                origReject(err);
            };
            return result;
        }
        catch (error) {
            endSpan(span, error);
            throw error;
        }
    };
};
//# sourceMappingURL=utils.js.map