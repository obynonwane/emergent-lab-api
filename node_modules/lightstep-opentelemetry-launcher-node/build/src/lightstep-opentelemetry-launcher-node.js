"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.configureOpenTelemetry = void 0;
const core_1 = require("@opentelemetry/core");
const api_1 = require("@opentelemetry/api");
const propagator_b3_1 = require("@opentelemetry/propagator-b3");
const sdk_node_1 = require("@opentelemetry/sdk-node");
const types = require("./types");
const exporter_collector_1 = require("@opentelemetry/exporter-collector");
const resources_1 = require("@opentelemetry/resources");
const os = require("os");
const auto_instrumentations_node_1 = require("@opentelemetry/auto-instrumentations-node");
const PROPAGATION_FORMATS = {
    B3: 'b3',
    B3SINGLE: 'b3single',
    TRACECONTEXT: 'tracecontext',
    BAGGAGE: 'baggage',
};
/** Map of propagation format to class implementing the format */
const PROPAGATOR_LOOKUP_MAP = {
    b3: propagator_b3_1.B3Propagator,
    b3single: propagator_b3_1.B3Propagator,
    tracecontext: core_1.HttpTraceContext,
    baggage: core_1.HttpBaggage,
};
/** Default values for LightstepNodeSDKConfiguration */
const LS_DEFAULTS = {
    spanEndpoint: 'https://ingest.lightstep.com/traces/otlp/v0.6',
    propagators: PROPAGATION_FORMATS.B3,
};
const ACCESS_TOKEN_HEADER = 'Lightstep-Access-Token';
let fail;
/**
 * Returns a NodeSDK object configured using Lightstep defaults with user
 * overrides. Call start on the returned NodeSDK instance to apply the
 * configuration and start the export pipeline.
 * @param config
 */
function configureOpenTelemetry(config = {}) {
    setupLogger(config);
    fail = config.failureHandler || defaultFailureHandler(api_1.diag);
    config = coalesceConfig(config);
    validateConfiguration(config);
    configureBaseResource(config);
    configurePropagation(config);
    configureTraceExporter(config);
    configureInstrumentations(config);
    return new sdk_node_1.NodeSDK(config);
}
exports.configureOpenTelemetry = configureOpenTelemetry;
/**
 * Setup up logger to use for Launcher. This may or may not be the logger
 * configured for OpenTelemetry. This is so we can print meaningful error
 * messages when configuration fails. Note, when provided by environment variable,
 * log level is interpreted as a string. In code configuration uses the LogLevel
 * enum from @openelemetry/core
 */
function setupLogger(config) {
    if (config.logger) {
        api_1.diag.setLogger(config.logger, config.logLevel);
        return;
    }
    let logLevel;
    if (config.logLevel !== undefined) {
        logLevel = config.logLevel;
    }
    else if (process.env.OTEL_LOG_LEVEL) {
        logLevel =
            api_1.DiagLogLevel[process.env.OTEL_LOG_LEVEL.toUpperCase()];
    }
    else {
        logLevel = api_1.DiagLogLevel.INFO;
    }
    api_1.diag.setLogger(new api_1.DiagConsoleLogger(), logLevel);
}
/**
 * Merges configuration with the following precedence: code config, config from
 * environment, default configuration. Returns a new configuration.
 * @param config
 */
function coalesceConfig(config) {
    const envConfig = configFromEnvironment();
    const mergedConfig = Object.assign(Object.assign(Object.assign({}, LS_DEFAULTS), envConfig), config);
    logConfig(LS_DEFAULTS, envConfig, config, mergedConfig);
    return mergedConfig;
}
/**
 * Log configuration from individual sources and the effective, merged config
 */
function logConfig(defaults, envConfig, lsConfig, mergedConfig) {
    api_1.diag.debug('Default config: ', defaults);
    api_1.diag.debug('Default config: ', defaults);
    api_1.diag.debug('Config from environment', envConfig);
    api_1.diag.debug('Default config: ', defaults);
    api_1.diag.debug('Config from code: ', lsConfig);
    api_1.diag.debug('Default config: ', defaults);
    api_1.diag.debug('Merged Config', mergedConfig);
}
/**
 * Iterates through known environment variable keys and returns an object with
 * keys using lightstep conventions
 */
function configFromEnvironment() {
    const env = process.env;
    const envConfig = {};
    if (env.LS_ACCESS_TOKEN)
        envConfig.accessToken = env.LS_ACCESS_TOKEN;
    if (env.LS_SERVICE_NAME)
        envConfig.serviceName = env.LS_SERVICE_NAME;
    if (env.LS_SERVICE_VERSION)
        envConfig.serviceVersion = env.LS_SERVICE_VERSION;
    if (env.OTEL_EXPORTER_OTLP_SPAN_ENDPOINT)
        envConfig.spanEndpoint = env.OTEL_EXPORTER_OTLP_SPAN_ENDPOINT;
    if (env.OTEL_PROPAGATORS)
        envConfig.propagators = env.OTEL_PROPAGATORS;
    return envConfig;
}
/**
 * The default failure handler. It logs a message at error level and raises
 * an exception. Can be overridden by passing a custom failureHandler in
 * LightstepNodeSDKConfiguration
 * @param logger
 */
function defaultFailureHandler(logger) {
    return (message) => {
        logger.error(message);
        throw new types.LightstepConfigurationError(message);
    };
}
/**
 * Makes upfront validations on configuration issues known to cause failures.
 * @param config
 */
function validateConfiguration(config) {
    validateToken(config);
    validateServiceName(config);
}
/**
 * Validates that a token is present if the spanEndpoint is for LS SaaS.
 * The token might be optional for other spanEndpoints, but will depend on their
 * configuration. If a token is provided, we validate its length.
 * @param config
 */
function validateToken(config) {
    if (!config.accessToken && config.spanEndpoint === LS_DEFAULTS.spanEndpoint) {
        fail(`Invalid configuration: access token missing, must be set when reporting to ${config.spanEndpoint}. Set LS_ACCESS_TOKEN env var or configure token in code`);
    }
    if (!config.accessToken) {
        return;
    }
    // valid access tokens are 32, 84 or 104 characters
    if (![32, 84, 104].includes(config.accessToken.length)) {
        fail('Invalid configuration: access token length incorrect. Ensure token is set correctly');
    }
}
/**
 * Validates that the service name is present
 * @param config
 */
function validateServiceName(config) {
    if (!config.serviceName)
        fail('Invalid configuration: service name missing. Set LS_SERVICE_NAME env var or configure serviceName in code');
}
function configureBaseResource(config) {
    const attributes = {
        [resources_1.SERVICE_RESOURCE.NAME]: config.serviceName,
    };
    if (config.serviceVersion) {
        attributes[resources_1.SERVICE_RESOURCE.VERSION] = config.serviceVersion;
    }
    attributes[resources_1.HOST_RESOURCE.NAME] = process.env.HOSTNAME || os.hostname();
    const baseResource = new resources_1.Resource(attributes);
    if (config.resource) {
        config.resource = baseResource.merge(config.resource);
    }
    else {
        config.resource = baseResource;
    }
}
/**
 * Configures instrumentations
 * @param config
 */
function configureInstrumentations(config) {
    if (config.instrumentations) {
        return;
    }
    config.instrumentations = [auto_instrumentations_node_1.getNodeAutoInstrumentations()];
}
/**
 * Configures export as JSON over HTTP to the configured spanEndpoint
 * @param config
 */
function configureTraceExporter(config) {
    if (config.traceExporter) {
        return;
    }
    const headers = {};
    if (config.accessToken) {
        headers[ACCESS_TOKEN_HEADER] = config.accessToken;
    }
    config.traceExporter = new exporter_collector_1.CollectorTraceExporter({
        serviceName: config.serviceName,
        url: config.spanEndpoint,
        headers,
    });
}
/**
 * Instantiates a propagator based on a string name where the name appears in
 * as a key in the PROPAGATOR_LOOKUP_MAP. Current supported names are: b3,
 * tracecontext, correlationcontext.
 * @param name
 */
function createPropagator(name) {
    const propagatorClass = PROPAGATOR_LOOKUP_MAP[name];
    if (!propagatorClass) {
        fail(`Invalid configuration: unknown propagator specified: ${name}. Supported propagators are: b3, b3single, baggage, tracecontext`);
    }
    if (name === 'b3') {
        return new propagatorClass({
            injectEncoding: propagator_b3_1.B3InjectEncoding.MULTI_HEADER,
        });
    }
    else if (name === 'b3single') {
        return new propagatorClass({
            injectEncoding: propagator_b3_1.B3InjectEncoding.SINGLE_HEADER,
        });
    }
    return new propagatorClass();
}
/**
 * Configures propagators based on a comma delimited string from the config.
 * If more than one propagator is specified, a composite propagator will be
 * configured with mutiple formats. Supported string formats are b3,
 * tracecontext, and correlationcontext.
 * @param config
 */
function configurePropagation(config) {
    var _a;
    if (config.textMapPropagator) {
        return;
    }
    const propagators = (((_a = config.propagators) === null || _a === void 0 ? void 0 : _a.split(',')) || [PROPAGATION_FORMATS.B3]).map(name => createPropagator(name.trim()));
    if (propagators.length > 1) {
        config.textMapPropagator = new core_1.CompositePropagator({ propagators });
    }
    else {
        config.textMapPropagator = propagators[0];
    }
}
//# sourceMappingURL=lightstep-opentelemetry-launcher-node.js.map